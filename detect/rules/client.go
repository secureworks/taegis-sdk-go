// Code generated by gql_clientgen, please do not edit

package rules

import (
	"github.com/secureworks/taegis-sdk-go/client"
	"github.com/secureworks/taegis-sdk-go/common"
	"github.com/secureworks/taegis-sdk-go/graphql"
	"context"
	"net/http"
	"time"
)

// Client provides an easy to use Go client to the Rules API
type Client struct {
	client   *client.Client
	url      string
	tenantID string
}

// New returns a new Client, ready for use
func New(url string, tenantID string) *Client {
	return NewWithClient(url, tenantID, client.NewClient())
}

// NewWithClient returns a new Client which uses the given client
func NewWithClient(url string, tenantID string, client *client.Client) *Client {
	return &Client{
		client:   client,
		tenantID: tenantID,
		url:      url,
	}
}

func (c *Client) makeRequest(ctx context.Context, req *graphql.Request, res interface{}) error {
	header := http.Header{}
	header.Add(common.XTenantContextHeader, c.tenantID)

	return graphql.ExecuteQueryContext(ctx, &graphql.QueryConfig{
		HClient:   c.client,
		Header:    header,
		Output:    res,
		Request:   req,
		ServerURL: c.url,
	})
}

const allRuleFields = `
	id
	tenantID
	userID
	eventType
	name
	description
	visibility
	resultVisibility
	severity
	confidence
	enabled
	createAlert
	tags
	destinationTopic
	attackCategories
	endpointPlatform
	references {` + allRuleReferenceFields + `
	}
	deleted
	createdAt
	updatedAt
	filters {` + allRuleFilterFields + `
	}
	redQLFilter {` + allRuleRedQLFilterFields + `
	}
`

const allRuleDailyCountFields = `
	count
	date
`

const allRuleEventDataFields = `
	key
	value
`

const allRuleFilterFields = `
	id
	ruleID
	key
	pattern
	inverted
	caseSensitive
	count {` + allRuleTermCountFields + `
	}
	testShould
	testShouldNot
	createdAt
	updatedAt
`

const allRuleMetricsFields = `
	last30DaysCount
	dailyCounts {` + allRuleDailyCountFields + `
	}
	lastHitDate
`

const allRuleRedQLFilterFields = `
	id
	ruleID
	query
	createdAt
	updatedAt
	testShould {` + allRuleRedQLFilterTestFields + `
	}
	testShouldNot {` + allRuleRedQLFilterTestFields + `
	}
`

const allRuleRedQLFilterTestFields = `
	fieldName
	fieldValue
`

const allRuleReferenceFields = `
	description
	url
`

const allRuleSampleEventFields = `
	data {` + allRuleEventDataFields + `
	}
`

const allRuleTermCountFields = `
	comparison
	value
`

const allRuleTestMatchStepFields = `
	filter {` + allRuleFilterFields + `
	}
	total
	matches
	duration
	samples {` + allRuleSampleEventFields + `
	}
`

// Rule is a named container for filters with some metadata
type Rule struct {
	ID               string                 `json:"id"`
	TenantID         string                 `json:"tenantID"`
	UserID           string                 `json:"userID"`
	EventType        RuleEventType          `json:"eventType"`
	Name             string                 `json:"name"`
	Description      string                 `json:"description"`
	Visibility       RuleVisibility         `json:"visibility"`
	ResultVisibility RuleVisibility         `json:"resultVisibility"`
	Severity         float32                `json:"severity"`
	Confidence       float32                `json:"confidence"`
	Enabled          bool                   `json:"enabled"`
	CreateAlert      bool                   `json:"createAlert"`
	Tags             []string               `json:"tags"`
	DestinationTopic *string                `json:"destinationTopic"`
	AttackCategories []string               `json:"attackCategories"`
	EndpointPlatform []RuleEndpointPlatform `json:"endpointPlatform"`
	References       []RuleReference        `json:"references"`
	Deleted          bool                   `json:"deleted"`
	CreatedAt        time.Time              `json:"createdAt"`
	UpdatedAt        time.Time              `json:"updatedAt"`
	Filters          []RuleFilter           `json:"filters"`
	RedQLFilter      *RuleRedQLFilter       `json:"redQLFilter"`
}

// The comparison operator used for counting filters
type RuleCountComparison string

const (
	RuleCountComparisonGreaterThan RuleCountComparison = "greater_than"
	RuleCountComparisonLessThan    RuleCountComparison = "less_than"
	RuleCountComparisonEqualTo     RuleCountComparison = "equal_to"
)

type RuleDailyCount struct {
	Count int    `json:"count"`
	Date  string `json:"date"`
}

// The possible platforms a rule can apply to
type RuleEndpointPlatform string

const (
	RuleEndpointPlatformPlatformWindows RuleEndpointPlatform = "PLATFORM_WINDOWS"
	RuleEndpointPlatformPlatformLinux   RuleEndpointPlatform = "PLATFORM_LINUX"
	RuleEndpointPlatformPlatformMac     RuleEndpointPlatform = "PLATFORM_MAC"
	RuleEndpointPlatformPlatformUnknown RuleEndpointPlatform = "PLATFORM_UNKNOWN"
)

// RuleEventData represents a single field in an event returned when testing rules
type RuleEventData struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

// The type of event a rule is intended to filter
type RuleEventType string

const (
	RuleEventTypeAuth            RuleEventType = "auth"
	RuleEventTypeDnsquery        RuleEventType = "dnsquery"
	RuleEventTypeFilemod         RuleEventType = "filemod"
	RuleEventTypeHTTP            RuleEventType = "http"
	RuleEventTypeManagementEvent RuleEventType = "management_event"
	RuleEventTypeNetflow         RuleEventType = "netflow"
	RuleEventTypeNids            RuleEventType = "nids"
	RuleEventTypeObservation     RuleEventType = "observation"
	RuleEventTypeObservationV2   RuleEventType = "observation_v2"
	RuleEventTypePersistence     RuleEventType = "persistence"
	RuleEventTypeProcess         RuleEventType = "process"
	RuleEventTypeRegistry        RuleEventType = "registry"
	RuleEventTypeScriptBlock     RuleEventType = "script_block"
	RuleEventTypeThreadInjection RuleEventType = "thread_injection"
)

// RuleFilter is a regular expression which should be applied to an event field
type RuleFilter struct {
	ID            string         `json:"id"`
	RuleID        string         `json:"ruleID"`
	Key           string         `json:"key"`
	Pattern       string         `json:"pattern"`
	Inverted      bool           `json:"inverted"`
	CaseSensitive bool           `json:"caseSensitive"`
	Count         *RuleTermCount `json:"count"`
	TestShould    []string       `json:"testShould"`
	TestShouldNot []string       `json:"testShouldNot"`
	CreatedAt     time.Time      `json:"createdAt"`
	UpdatedAt     time.Time      `json:"updatedAt"`
}

type RuleFilterInput struct {
	Key           string              `json:"key"`
	Pattern       string              `json:"pattern"`
	Inverted      *bool               `json:"inverted"`
	CaseSensitive *bool               `json:"caseSensitive"`
	Count         *RuleTermCountInput `json:"count"`
	TestShould    []string            `json:"testShould"`
	TestShouldNot []string            `json:"testShouldNot"`
}

type RuleInput struct {
	ID               *string                `json:"id"`
	EventType        *RuleEventType         `json:"eventType"`
	Name             *string                `json:"name"`
	Description      *string                `json:"description"`
	Visibility       *RuleVisibility        `json:"visibility"`
	ResultVisibility *RuleVisibility        `json:"resultVisibility"`
	Severity         *float32               `json:"severity"`
	Confidence       *float32               `json:"confidence"`
	CreateAlert      *bool                  `json:"createAlert"`
	Tags             []string               `json:"tags"`
	DestinationTopic *string                `json:"destinationTopic"`
	AttackCategories []string               `json:"attackCategories"`
	EndpointPlatform []RuleEndpointPlatform `json:"endpointPlatform"`
	References       []RuleReferenceInput   `json:"references"`
}

type RuleMetrics struct {
	Last30DaysCount int              `json:"last30DaysCount"`
	DailyCounts     []RuleDailyCount `json:"dailyCounts"`
	LastHitDate     string           `json:"lastHitDate"`
}

// RedQLFilter is a redql query string that is applied to events.
type RuleRedQLFilter struct {
	ID            string                `json:"id"`
	RuleID        string                `json:"ruleID"`
	Query         string                `json:"query"`
	CreatedAt     time.Time             `json:"createdAt"`
	UpdatedAt     time.Time             `json:"updatedAt"`
	TestShould    []RuleRedQLFilterTest `json:"testShould"`
	TestShouldNot []RuleRedQLFilterTest `json:"testShouldNot"`
}

type RuleRedQLFilterInput struct {
	Query         string                     `json:"query"`
	TestShould    []RuleRedQLFilterTestInput `json:"testShould"`
	TestShouldNot []RuleRedQLFilterTestInput `json:"testShouldNot"`
}

// RedQLFilterTest is key/value pair used to validate redql filters.
type RuleRedQLFilterTest struct {
	FieldName  string `json:"fieldName"`
	FieldValue string `json:"fieldValue"`
}

type RuleRedQLFilterTestInput struct {
	FieldName  string `json:"fieldName"`
	FieldValue string `json:"fieldValue"`
}

// RuleReference refers to an exploit or security threat associated with this rule
type RuleReference struct {
	Description string `json:"description"`
	URL         string `json:"url"`
}

type RuleReferenceInput struct {
	Description string `json:"description"`
	URL         string `json:"url"`
}

// RuleSampleEvent is an event that was found when testing a rule that represents
// the kind of event the rule matches.
type RuleSampleEvent struct {
	Data []RuleEventData `json:"data"`
}

// RuleTermCount is used for filters which are supposed to count the number of matches
type RuleTermCount struct {
	Comparison RuleCountComparison `json:"comparison"`
	Value      int                 `json:"value"`
}

type RuleTermCountInput struct {
	Comparison RuleCountComparison `json:"comparison"`
	Value      int                 `json:"value"`
}

// RuleTestMatchStep is a step in the evaluation of a rule which corresponds to a
// filter and shows how many total events were filtered into the matched events and
// also provides the duration of time the filter operation took as well as some
// sample events to show the sort of events that matched.
type RuleTestMatchStep struct {
	Filter   RuleFilter        `json:"filter"`
	Total    int               `json:"total"`
	Matches  int               `json:"matches"`
	Duration string            `json:"duration"`
	Samples  []RuleSampleEvent `json:"samples"`
}

// The type of rule; old rules are regex, new rules are redql
type RuleType string

const (
	RuleTypeRegex RuleType = "REGEX"
	RuleTypeRedql RuleType = "REDQL"
)

// The visibility of global rules
type RuleVisibility string

const (
	RuleVisibilityVisible RuleVisibility = "visible"
	RuleVisibilityHidden  RuleVisibility = "hidden"
)

// GetRulesCtx will return pages of all rules, sorted by descending updated at date
func (c *Client) GetRulesCtx(ctx context.Context, page *int, count *int, ruleType *RuleType) ([]*Rule, error) {
	req := graphql.NewRequest(`query($page: Int, $count: Int, $ruleType: RuleType) {
		rules(page: $page, count: $count, ruleType: $ruleType) {` + allRuleFields + `
		}
	}`)
	req.Var("page", page)
	req.Var("count", count)
	req.Var("ruleType", ruleType)

	var res struct {
		Rules []*Rule `json:"rules"`
	}
	if err := c.makeRequest(ctx, req, &res); err != nil {
		return nil, err
	}

	return res.Rules, nil
}

// GetRules will return pages of all rules, sorted by descending updated at date
func (c *Client) GetRules(page *int, count *int, ruleType *RuleType) ([]*Rule, error) {
	return c.GetRulesCtx(context.Background(), page, count, ruleType)
}

// GetDeletedRulesCtx will return deleted rules
func (c *Client) GetDeletedRulesCtx(ctx context.Context, page *int, count *int, ruleType *RuleType) ([]*Rule, error) {
	req := graphql.NewRequest(`query($page: Int, $count: Int, $ruleType: RuleType) {
		deletedRules(page: $page, count: $count, ruleType: $ruleType) {` + allRuleFields + `
		}
	}`)
	req.Var("page", page)
	req.Var("count", count)
	req.Var("ruleType", ruleType)

	var res struct {
		DeletedRules []*Rule `json:"deletedRules"`
	}
	if err := c.makeRequest(ctx, req, &res); err != nil {
		return nil, err
	}

	return res.DeletedRules, nil
}

// GetDeletedRules will return deleted rules
func (c *Client) GetDeletedRules(page *int, count *int, ruleType *RuleType) ([]*Rule, error) {
	return c.GetDeletedRulesCtx(context.Background(), page, count, ruleType)
}

// GetRulesCountCtx will return a count of all rules
func (c *Client) GetRulesCountCtx(ctx context.Context, ruleType *RuleType) (int, error) {
	req := graphql.NewRequest(`query($ruleType: RuleType) {
		rulesCount(ruleType: $ruleType)
	}`)
	req.Var("ruleType", ruleType)

	var res struct {
		RulesCount int `json:"rulesCount"`
	}
	if err := c.makeRequest(ctx, req, &res); err != nil {
		return 0, err
	}

	return res.RulesCount, nil
}

// GetRulesCount will return a count of all rules
func (c *Client) GetRulesCount(ruleType *RuleType) (int, error) {
	return c.GetRulesCountCtx(context.Background(), ruleType)
}

// GetRulesForEventArguments is the parameters for GetRulesForEvent
type GetRulesForEventArguments struct {
	EventType RuleEventType `json:"eventType"`
	Page      *int          `json:"page"`
	Count     *int          `json:"count"`
	RuleType  *RuleType     `json:"ruleType"`
}

// GetRulesForEventCtx will return pages of rules for the given event type, sorted by descending updated at date
func (c *Client) GetRulesForEventCtx(ctx context.Context, params *GetRulesForEventArguments) ([]*Rule, error) {
	req := graphql.NewRequest(`query($eventType: RuleEventType!, $page: Int, $count: Int, $ruleType: RuleType) {
		rulesForEvent(eventType: $eventType, page: $page, count: $count, ruleType: $ruleType) {` + allRuleFields + `
		}
	}`)
	req.Var("eventType", params.EventType)
	req.Var("page", params.Page)
	req.Var("count", params.Count)
	req.Var("ruleType", params.RuleType)

	var res struct {
		RulesForEvent []*Rule `json:"rulesForEvent"`
	}
	if err := c.makeRequest(ctx, req, &res); err != nil {
		return nil, err
	}

	return res.RulesForEvent, nil
}

// GetRulesForEvent will return pages of rules for the given event type, sorted by descending updated at date
func (c *Client) GetRulesForEvent(params *GetRulesForEventArguments) ([]*Rule, error) {
	return c.GetRulesForEventCtx(context.Background(), params)
}

// GetRulesForEventCountCtx will return a count of all rules for the given event type
func (c *Client) GetRulesForEventCountCtx(ctx context.Context, eventType RuleEventType, ruleType *RuleType) (int, error) {
	req := graphql.NewRequest(`query($eventType: RuleEventType!, $ruleType: RuleType) {
		rulesForEventCount(eventType: $eventType, ruleType: $ruleType)
	}`)
	req.Var("eventType", eventType)
	req.Var("ruleType", ruleType)

	var res struct {
		RulesForEventCount int `json:"rulesForEventCount"`
	}
	if err := c.makeRequest(ctx, req, &res); err != nil {
		return 0, err
	}

	return res.RulesForEventCount, nil
}

// GetRulesForEventCount will return a count of all rules for the given event type
func (c *Client) GetRulesForEventCount(eventType RuleEventType, ruleType *RuleType) (int, error) {
	return c.GetRulesForEventCountCtx(context.Background(), eventType, ruleType)
}

// GetRuleCtx will get the rule with this ID
func (c *Client) GetRuleCtx(ctx context.Context, id string) (*Rule, error) {
	req := graphql.NewRequest(`query($id: ID!) {
		rule(id: $id) {` + allRuleFields + `
		}
	}`)
	req.Var("id", id)

	var res struct {
		Rule *Rule `json:"rule"`
	}
	if err := c.makeRequest(ctx, req, &res); err != nil {
		return nil, err
	}

	return res.Rule, nil
}

// GetRule will get the rule with this ID
func (c *Client) GetRule(id string) (*Rule, error) {
	return c.GetRuleCtx(context.Background(), id)
}

// GetFilterKeysCtx will return a list of all valid filter keys for the given event type
func (c *Client) GetFilterKeysCtx(ctx context.Context, eventType RuleEventType) ([]string, error) {
	req := graphql.NewRequest(`query($eventType: RuleEventType!) {
		filterKeys(eventType: $eventType)
	}`)
	req.Var("eventType", eventType)

	var res struct {
		FilterKeys []string `json:"filterKeys"`
	}
	if err := c.makeRequest(ctx, req, &res); err != nil {
		return nil, err
	}

	return res.FilterKeys, nil
}

// GetFilterKeys will return a list of all valid filter keys for the given event type
func (c *Client) GetFilterKeys(eventType RuleEventType) ([]string, error) {
	return c.GetFilterKeysCtx(context.Background(), eventType)
}

// GetChangesSinceCtx will return all rules that changed since the given time.
//
// The provided time will be compared to the updated at time of the rules and
// if any of those are greater than the provided time, that rule (and its
// filters) will be returned.
//
// The event type, if provided, will limit the returned rules to those for that
// event type.
//
// If no rules or filters have changed since that time, nothing will be returned.
//
// This can be used by clients to easily see when rules have been edited by
// polling this endpoint periodically, passing in the last time they checked.
func (c *Client) GetChangesSinceCtx(ctx context.Context, timestamp time.Time, eventType *RuleEventType, ruleType *RuleType) ([]*Rule, error) {
	req := graphql.NewRequest(`query($timestamp: Time!, $eventType: RuleEventType, $ruleType: RuleType) {
		changesSince(timestamp: $timestamp, eventType: $eventType, ruleType: $ruleType) {` + allRuleFields + `
		}
	}`)
	req.Var("timestamp", timestamp)
	req.Var("eventType", eventType)
	req.Var("ruleType", ruleType)

	var res struct {
		ChangesSince []*Rule `json:"changesSince"`
	}
	if err := c.makeRequest(ctx, req, &res); err != nil {
		return nil, err
	}

	return res.ChangesSince, nil
}

// GetChangesSince will return all rules that changed since the given time.
//
// The provided time will be compared to the updated at time of the rules and
// if any of those are greater than the provided time, that rule (and its
// filters) will be returned.
//
// The event type, if provided, will limit the returned rules to those for that
// event type.
//
// If no rules or filters have changed since that time, nothing will be returned.
//
// This can be used by clients to easily see when rules have been edited by
// polling this endpoint periodically, passing in the last time they checked.
func (c *Client) GetChangesSince(timestamp time.Time, eventType *RuleEventType, ruleType *RuleType) ([]*Rule, error) {
	return c.GetChangesSinceCtx(context.Background(), timestamp, eventType, ruleType)
}

// CreateRuleCtx will create the given new rule, with optional filters
func (c *Client) CreateRuleCtx(ctx context.Context, input RuleInput, filters []RuleFilterInput) (Rule, error) {
	req := graphql.NewRequest(`mutation($input: RuleInput!, $filters: [RuleFilterInput!]) {
		createRule(input: $input, filters: $filters) {` + allRuleFields + `
		}
	}`)
	req.Var("input", input)
	req.Var("filters", filters)

	var res struct {
		CreateRule Rule `json:"createRule"`
	}
	if err := c.makeRequest(ctx, req, &res); err != nil {
		return Rule{}, err
	}

	return res.CreateRule, nil
}

// CreateRule will create the given new rule, with optional filters
func (c *Client) CreateRule(input RuleInput, filters []RuleFilterInput) (Rule, error) {
	return c.CreateRuleCtx(context.Background(), input, filters)
}

// AddFilterToRuleCtx will add the provided filter to the rule with the given ID
func (c *Client) AddFilterToRuleCtx(ctx context.Context, ruleID string, filter RuleFilterInput) (RuleFilter, error) {
	req := graphql.NewRequest(`mutation($ruleID: ID!, $filter: RuleFilterInput!) {
		addFilterToRule(ruleID: $ruleID, filter: $filter) {` + allRuleFilterFields + `
		}
	}`)
	req.Var("ruleID", ruleID)
	req.Var("filter", filter)

	var res struct {
		AddFilterToRule RuleFilter `json:"addFilterToRule"`
	}
	if err := c.makeRequest(ctx, req, &res); err != nil {
		return RuleFilter{}, err
	}

	return res.AddFilterToRule, nil
}

// AddFilterToRule will add the provided filter to the rule with the given ID
func (c *Client) AddFilterToRule(ruleID string, filter RuleFilterInput) (RuleFilter, error) {
	return c.AddFilterToRuleCtx(context.Background(), ruleID, filter)
}

// UpdateRuleCtx will update the given rule, without changing the filters
func (c *Client) UpdateRuleCtx(ctx context.Context, ruleID string, rule RuleInput) (Rule, error) {
	req := graphql.NewRequest(`mutation($ruleID: ID!, $rule: RuleInput!) {
		updateRule(ruleID: $ruleID, rule: $rule) {` + allRuleFields + `
		}
	}`)
	req.Var("ruleID", ruleID)
	req.Var("rule", rule)

	var res struct {
		UpdateRule Rule `json:"updateRule"`
	}
	if err := c.makeRequest(ctx, req, &res); err != nil {
		return Rule{}, err
	}

	return res.UpdateRule, nil
}

// UpdateRule will update the given rule, without changing the filters
func (c *Client) UpdateRule(ruleID string, rule RuleInput) (Rule, error) {
	return c.UpdateRuleCtx(context.Background(), ruleID, rule)
}

// DeleteRuleCtx will delete the given rule
func (c *Client) DeleteRuleCtx(ctx context.Context, ruleID string) (Rule, error) {
	req := graphql.NewRequest(`mutation($ruleID: ID!) {
		deleteRule(ruleID: $ruleID) {` + allRuleFields + `
		}
	}`)
	req.Var("ruleID", ruleID)

	var res struct {
		DeleteRule Rule `json:"deleteRule"`
	}
	if err := c.makeRequest(ctx, req, &res); err != nil {
		return Rule{}, err
	}

	return res.DeleteRule, nil
}

// DeleteRule will delete the given rule
func (c *Client) DeleteRule(ruleID string) (Rule, error) {
	return c.DeleteRuleCtx(context.Background(), ruleID)
}

// UpdateFilterCtx will update the given filter
func (c *Client) UpdateFilterCtx(ctx context.Context, filterID string, filter RuleFilterInput) (RuleFilter, error) {
	req := graphql.NewRequest(`mutation($filterID: ID!, $filter: RuleFilterInput!) {
		updateFilter(filterID: $filterID, filter: $filter) {` + allRuleFilterFields + `
		}
	}`)
	req.Var("filterID", filterID)
	req.Var("filter", filter)

	var res struct {
		UpdateFilter RuleFilter `json:"updateFilter"`
	}
	if err := c.makeRequest(ctx, req, &res); err != nil {
		return RuleFilter{}, err
	}

	return res.UpdateFilter, nil
}

// UpdateFilter will update the given filter
func (c *Client) UpdateFilter(filterID string, filter RuleFilterInput) (RuleFilter, error) {
	return c.UpdateFilterCtx(context.Background(), filterID, filter)
}

// DeleteFilterCtx will delete the given Regex filter, and return it
func (c *Client) DeleteFilterCtx(ctx context.Context, filterID string) (RuleFilter, error) {
	req := graphql.NewRequest(`mutation($filterID: ID!) {
		deleteFilter(filterID: $filterID) {` + allRuleFilterFields + `
		}
	}`)
	req.Var("filterID", filterID)

	var res struct {
		DeleteFilter RuleFilter `json:"deleteFilter"`
	}
	if err := c.makeRequest(ctx, req, &res); err != nil {
		return RuleFilter{}, err
	}

	return res.DeleteFilter, nil
}

// DeleteFilter will delete the given Regex filter, and return it
func (c *Client) DeleteFilter(filterID string) (RuleFilter, error) {
	return c.DeleteFilterCtx(context.Background(), filterID)
}

// CreateRedQLRuleCtx will create the given new rule with a redql filter
func (c *Client) CreateRedQLRuleCtx(ctx context.Context, input RuleInput, redQLFilter RuleRedQLFilterInput) (Rule, error) {
	req := graphql.NewRequest(`mutation($input: RuleInput!, $redQLFilter: RuleRedQLFilterInput!) {
		createRedQLRule(input: $input, redQLFilter: $redQLFilter) {` + allRuleFields + `
		}
	}`)
	req.Var("input", input)
	req.Var("redQLFilter", redQLFilter)

	var res struct {
		CreateRedQLRule Rule `json:"createRedQLRule"`
	}
	if err := c.makeRequest(ctx, req, &res); err != nil {
		return Rule{}, err
	}

	return res.CreateRedQLRule, nil
}

// CreateRedQLRule will create the given new rule with a redql filter
func (c *Client) CreateRedQLRule(input RuleInput, redQLFilter RuleRedQLFilterInput) (Rule, error) {
	return c.CreateRedQLRuleCtx(context.Background(), input, redQLFilter)
}

// UpdateRedQLFilterCtx will update the given RedQL Filter
func (c *Client) UpdateRedQLFilterCtx(ctx context.Context, filterID string, redQLFilter RuleRedQLFilterInput) (RuleRedQLFilter, error) {
	req := graphql.NewRequest(`mutation($filterID: ID!, $redQLFilter: RuleRedQLFilterInput!) {
		updateRedQLFilter(filterID: $filterID, redQLFilter: $redQLFilter) {` + allRuleRedQLFilterFields + `
		}
	}`)
	req.Var("filterID", filterID)
	req.Var("redQLFilter", redQLFilter)

	var res struct {
		UpdateRedQLFilter RuleRedQLFilter `json:"updateRedQLFilter"`
	}
	if err := c.makeRequest(ctx, req, &res); err != nil {
		return RuleRedQLFilter{}, err
	}

	return res.UpdateRedQLFilter, nil
}

// UpdateRedQLFilter will update the given RedQL Filter
func (c *Client) UpdateRedQLFilter(filterID string, redQLFilter RuleRedQLFilterInput) (RuleRedQLFilter, error) {
	return c.UpdateRedQLFilterCtx(context.Background(), filterID, redQLFilter)
}

// DisableRuleCtx will disable the rule with the given ID
func (c *Client) DisableRuleCtx(ctx context.Context, id string) (Rule, error) {
	req := graphql.NewRequest(`mutation($id: ID!) {
		disableRule(id: $id) {` + allRuleFields + `
		}
	}`)
	req.Var("id", id)

	var res struct {
		DisableRule Rule `json:"disableRule"`
	}
	if err := c.makeRequest(ctx, req, &res); err != nil {
		return Rule{}, err
	}

	return res.DisableRule, nil
}

// DisableRule will disable the rule with the given ID
func (c *Client) DisableRule(id string) (Rule, error) {
	return c.DisableRuleCtx(context.Background(), id)
}

// EnableRuleCtx will enable the rule with the given ID
func (c *Client) EnableRuleCtx(ctx context.Context, id string) (Rule, error) {
	req := graphql.NewRequest(`mutation($id: ID!) {
		enableRule(id: $id) {` + allRuleFields + `
		}
	}`)
	req.Var("id", id)

	var res struct {
		EnableRule Rule `json:"enableRule"`
	}
	if err := c.makeRequest(ctx, req, &res); err != nil {
		return Rule{}, err
	}

	return res.EnableRule, nil
}

// EnableRule will enable the rule with the given ID
func (c *Client) EnableRule(id string) (Rule, error) {
	return c.EnableRuleCtx(context.Background(), id)
}
