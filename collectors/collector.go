// Code generated by gql_clientgen, please do not edit

package collectors

import (
	"context"
	"net/http"
	"time"

	"github.com/secureworks/taegis-sdk-go/client"
	"github.com/secureworks/taegis-sdk-go/common"
	"github.com/secureworks/taegis-sdk-go/graphql"
	prometheus "github.com/prometheus/common/model"
	v1 "k8s.io/api/core/v1"
)

// Client provides an easy to use Go client to the collectors API
type Client struct {
	client   *client.Client
	url      string
	tenantID string
}

// New returns a new Client, ready for use
func New(url string, tenantID string) *Client {
	return NewWithClient(url, tenantID, client.NewClient())
}

// NewWithClient returns a new Client which uses the given client
func NewWithClient(url string, tenantID string, client *client.Client) *Client {
	return &Client{
		client:   client,
		tenantID: tenantID,
		url:      url,
	}
}

func (c *Client) makeRequest(ctx context.Context, req *graphql.Request, res interface{}) error {
	header := http.Header{}
	header.Add(common.XTenantContextHeader, c.tenantID)

	return graphql.ExecuteQueryContext(ctx, &graphql.QueryConfig{
		HClient:   c.client,
		Header:    header,
		Output:    res,
		Request:   req,
		ServerURL: c.url,
	})
}

const allAggregateRateByCollectorFields = `
	aggregateRate
`

const allChartFields = `
	apiVersion
	appVersion
	name
	description
	icon
	home
	keywords
	version
	digest
	urls
	metaData
`

const allChartListFields = `
	APIVersion
	Entries
	Generated
`

const allClusterFields = `
	createdAt
	updatedAt
	id
	role
	name
	type
	description
	network {` + allNetworkFields + `
	}
	deployments {` + allDeploymentFields + `
	}
	status {` + allStatusFields + `
	}
	health
	registration {` + allRegistrationFields + `
	}
`

const allCollectorMetricsFields = `
	lastSeen
	averageRate
`

const allCollectorOverviewFields = `
	cluster {` + allClusterFields + `
	}
	lastSeen
	averageRate
`

const allCredentialsFields = `
	password
	privateKey
	publicKey
`

const allDeletedFields = `
	type
	id
	successful
`

const allDeploymentFields = `
	createdAt
	updatedAt
	id
	role
	name
	description
	chart
	version
	config
	status {` + allStatusFields + `
	}
	endpoints {` + allEndpointFields + `
	}
`

const allEndpointFields = `
	createdAt
	updatedAt
	id
	description
	address
	port
	credentials
`

const allFlowRateFields = `
	perFlowMax
	perFlowAverage
`

const allImageFields = `
	location
`

const allLogLastSeenMetricFields = `
	clusterID
	clusterName
	sourceID
	aliases
	service
	sensorType
	lastSeen
	health
`

const allLogLastSeenMetricsFields = `
	logMetrics {` + allLogLastSeenMetricFields + `
	}
`

const allNetworkFields = `
	dhcp
	hostname
	hosts
	address
	mask
	gateway
	dns
	ntp
	proxy
`

const allOSConfigFields = `
	createdAt
	updatedAt
	clusterID
	status
	statusMessage
	dhcp
	hostname
	hosts
	address
	mask
	gateway
	dns
	ntp
	proxy
`

const allRegistrationFields = `
	id
	region
`

const allStatusFields = `
	name
	createdAt
	updatedAt
	id
	status
`

type Any interface{}

// The awsDetails input struct contains the necessary identifying information for use with an AWS image download
type AWSDetails struct {
	AccountID string `json:"accountID"`
	Region    string `json:"region"`
}

// The aggregate rate metrics structure represents a set of aggregated collector data flow rate metrics
type AggregateRateByCollector struct {
	AggregateRate *Matrix `json:"aggregateRate"`
}

// The chart structure represents the the attributes associated with a given helm chart
type Chart struct {
	ApiVersion  *string  `json:"apiVersion"`
	AppVersion  *string  `json:"appVersion"`
	Name        *string  `json:"name"`
	Description *string  `json:"description"`
	Icon        *string  `json:"icon"`
	Home        *string  `json:"home"`
	Keywords    []string `json:"keywords"`
	Version     *string  `json:"version"`
	Digest      *string  `json:"digest"`
	Urls        []string `json:"urls"`
	MetaData    *Any     `json:"metaData"`
}

// The chart list structure represents a list of 'helm chart' entries available for installation in our repositories
type ChartList struct {
	APIVersion *string    `json:"APIVersion"`
	Entries    *Any       `json:"Entries"`
	Generated  *time.Time `json:"Generated"`
}

// The cluster structure represents the attributes of a data collector
type Cluster struct {
	CreatedAt    *time.Time    `json:"createdAt"`
	UpdatedAt    *time.Time    `json:"updatedAt"`
	ID           string        `json:"id"`
	Role         *string       `json:"role"`
	Name         *string       `json:"name"`
	Type         *string       `json:"type"`
	Description  *string       `json:"description"`
	Network      *Network      `json:"network"`
	Deployments  []Deployment  `json:"deployments"`
	Status       []Status      `json:"status"`
	Health       *string       `json:"health"`
	Registration *Registration `json:"registration"`
}

// ClusterInput is the corresponding input type for a cluster object.
// Note that the deployments, and status fields are not 'updateable'.
// To update the deployment and status data, please use their corresponding deployment and status mutation endpoints.
type ClusterInput struct {
	Name        *string           `json:"name"`
	Description *string           `json:"description"`
	Network     *NetworkInput     `json:"network"`
	Deployments []DeploymentInput `json:"deployments"`
	Status      []StatusInput     `json:"status"`
	Role        *string           `json:"role"`
	ClusterType *ClusterType      `json:"clusterType"`
}

// ClusterType holds the available cluster type enums meant to represent whether a cluster is on prem or cloud hosted
type ClusterType string

const (
	ClusterTypeOnprem ClusterType = "ONPREM"
	ClusterTypeCloud  ClusterType = "CLOUD"
)

// The collector metrics structure represents a set of collector data metrics
type CollectorMetrics struct {
	LastSeen    *Vector `json:"lastSeen"`
	AverageRate *Vector `json:"averageRate"`
}

// CollectorOverview combines a Cluster with its corresponding lastSeen and averageRate metrics.
// Check the CollectorMetrics type for more information on the latter.
type CollectorOverview struct {
	Cluster     Cluster `json:"cluster"`
	LastSeen    *Sample `json:"lastSeen"`
	AverageRate *Sample `json:"averageRate"`
}

type ConfigStatus string

const (
	ConfigStatusCSNew      ConfigStatus = "CSNew"
	ConfigStatusCSInflight ConfigStatus = "CSInflight"
	ConfigStatusCSSuccess  ConfigStatus = "CSSuccess"
	ConfigStatusCSFailed   ConfigStatus = "CSFailed"
)

// The credentials structure represents a set of credential attributes with regards to local access for a given collector
type Credentials struct {
	Password   *string `json:"password"`
	PrivateKey *string `json:"privateKey"`
	PublicKey  *string `json:"publicKey"`
}

// Deleted represents a structure containing metadata related the action of deleting an arbitrary object
type Deleted struct {
	Type       string `json:"type"`
	ID         string `json:"id"`
	Successful bool   `json:"successful"`
}

// Deployment defines helm package and config
type Deployment struct {
	CreatedAt   *time.Time `json:"createdAt"`
	UpdatedAt   *time.Time `json:"updatedAt"`
	ID          string     `json:"id"`
	Role        *string    `json:"role"`
	Name        *string    `json:"name"`
	Description *string    `json:"description"`
	Chart       *string    `json:"chart"`
	Version     *string    `json:"version"`
	Config      *Map       `json:"config"`
	Status      *Status    `json:"status"`
	Endpoints   []Endpoint `json:"endpoints"`
}

// DeploymentInput is the corresponding input type for a deployment object
type DeploymentInput struct {
	Name        *string         `json:"name"`
	Description *string         `json:"description"`
	Chart       *string         `json:"chart"`
	Version     *string         `json:"version"`
	Config      *Map            `json:"config"`
	Endpoints   []EndpointInput `json:"endpoints"`
}

// Endpoint defines API endpoints and credentials that applications would collect data from
type Endpoint struct {
	CreatedAt   *time.Time `json:"createdAt"`
	UpdatedAt   *time.Time `json:"updatedAt"`
	ID          string     `json:"id"`
	Description *string    `json:"description"`
	Address     *string    `json:"address"`
	Port        *int       `json:"port"`
	Credentials *Map       `json:"credentials"`
}

// EndpointInput is the corresponding input type for an endpoint object
type EndpointInput struct {
	Description *string `json:"description"`
	Address     *string `json:"address"`
	Port        *int    `json:"port"`
	Credentials *Map    `json:"credentials"`
}

// The aggregate flow rate metrics structure represents a set of collector data flow rate metrics.
// Note that if custom host->address mappings, as returned by getHosts, are found they will be included or updated in the src_dns field.
type FlowRate struct {
	PerFlowMax     *Vector `json:"perFlowMax"`
	PerFlowAverage *Vector `json:"perFlowAverage"`
}

// Hosts holds a mapping of addresses to hostnames that the cluster uses
type Hosts map[string][]string

// The hosts input structure represents a set ip address->hostname mappings used by a data collector.
// These host alias mappings can be considered as analogous to an /etc/hosts file
type HostsInput struct {
	Address  string `json:"address"`
	Hostname string `json:"hostname"`
}

// Image represents the object that contains a given cluster's image metadata (such as an image download link)
type Image struct {
	Location string `json:"location"`
}

// ImageType holds the available and supported collector image type enums
type ImageType string

const (
	ImageTypeAmi   ImageType = "AMI"
	ImageTypeVhd   ImageType = "VHD"
	ImageTypeOva   ImageType = "OVA"
	ImageTypeAzure ImageType = "AZURE"
)

// KubernetesConfig is a custom scalar representing an arbitrary YAML formatted Kubernetes configuration
type KubernetesConfig v1.List

// LogLastSeenMetric contains all of the relevant metadata to identify a log source as well as a 'lastSeen' timestamp
// which stores the last time that this log source was seen. A health status is also determined based on the recent ingest
// rate from this log source and how it compares to its historical ingest rate. 1 standard deviation away from the historical
// average is considered to be 'HEALTHY'. Anything greater than 1 but less than 2 standard deviations away is considered 'DEGRADED'.
// Anything greater than 2 standard deviations is considered 'UNHEALTHY'. If a health status cannot be determined due to an
// error or insufficient data then the returned health status will be 'UNKNOWN'.
type LogLastSeenMetric struct {
	ClusterID   string     `json:"clusterID"`
	ClusterName *string    `json:"clusterName"`
	SourceID    *string    `json:"sourceID"`
	Aliases     []string   `json:"aliases"`
	Service     *string    `json:"service"`
	SensorType  *string    `json:"sensorType"`
	LastSeen    *time.Time `json:"lastSeen"`
	Health      *string    `json:"health"`
}

// LogLastSeenMetrics holds log health data for all recorded log sources for a given collector
type LogLastSeenMetrics struct {
	LogMetrics []LogLastSeenMetric `json:"logMetrics"`
}

// Matrix is a custom scalar that is a one to one representation of the equivalent Prometheus API
// type you can find more information on in the link over 'Vector'. Matrix is currently only returned
// by one graphql endpoint.
type Matrix prometheus.Matrix

type Map map[string]interface{}

// The network structure represents the network configuration attributes for a given data collector
type Network struct {
	Dhcp     *bool        `json:"dhcp"`
	Hostname *string      `json:"hostname"`
	Hosts    *Hosts       `json:"hosts"`
	Address  *string      `json:"address"`
	Mask     *string      `json:"mask"`
	Gateway  *string      `json:"gateway"`
	Dns      *StringSlice `json:"dns"`
	Ntp      *StringSlice `json:"ntp"`
	Proxy    *string      `json:"proxy"`
}

// NetworkInput is the corresponding input type for a network object
type NetworkInput struct {
	Dhcp     *bool        `json:"dhcp"`
	Hostname *string      `json:"hostname"`
	Hosts    []HostsInput `json:"hosts"`
	Address  *string      `json:"address"`
	Mask     *string      `json:"mask"`
	Gateway  *string      `json:"gateway"`
	Dns      []string     `json:"dns"`
	Ntp      []string     `json:"ntp"`
	Proxy    *string      `json:"proxy"`
}

type OSConfig struct {
	CreatedAt     time.Time     `json:"createdAt"`
	UpdatedAt     time.Time     `json:"updatedAt"`
	ClusterID     string        `json:"clusterID"`
	Status        *ConfigStatus `json:"status"`
	StatusMessage *string       `json:"statusMessage"`
	Dhcp          *bool         `json:"dhcp"`
	Hostname      string        `json:"hostname"`
	Hosts         *Hosts        `json:"hosts"`
	Address       string        `json:"address"`
	Mask          string        `json:"mask"`
	Gateway       string        `json:"gateway"`
	Dns           *StringSlice  `json:"dns"`
	Ntp           *StringSlice  `json:"ntp"`
	Proxy         string        `json:"proxy"`
}

type OSConfigInput struct {
	ClusterID     string       `json:"clusterID"`
	Status        ConfigStatus `json:"status"`
	StatusMessage *string      `json:"statusMessage"`
	Dhcp          *bool        `json:"dhcp"`
	Hostname      *string      `json:"hostname"`
	Hosts         []HostsInput `json:"hosts"`
	Address       *string      `json:"address"`
	Mask          *string      `json:"mask"`
	Gateway       *string      `json:"gateway"`
	Dns           []string     `json:"dns"`
	Ntp           []string     `json:"ntp"`
	Proxy         *string      `json:"proxy"`
}

// Registration represents the object that contains a given cluster's SSM id and region information
type Registration struct {
	ID     *string `json:"id"`
	Region *string `json:"region"`
}

// Sample is a custom scalar that is a one to one representation of the equivalent Prometheus API
// type you can see here https://pkg.go.dev/github.com/prometheus/common/model?tab=doc#Sample .
// This type is returned by some Prometheus graphQL queries.
type Sample prometheus.Sample

// The status structure represents an overview of a collector's health and readiness status with regards to its own deployments
type Status struct {
	Name      *string    `json:"name"`
	CreatedAt *time.Time `json:"createdAt"`
	UpdatedAt *time.Time `json:"updatedAt"`
	ID        string     `json:"id"`
	Status    *Map       `json:"status"`
}

// StatusInput is the corresponding input type for a status object
type StatusInput struct {
	DeploymentID string  `json:"deploymentID"`
	Name         *string `json:"name"`
	Status       *Map    `json:"status"`
}

type StringSlice []string

// TimeRange holds the available time range enums accepted by the prometheus query endpoints
type TimeRange string

const (
	TimeRangeLasthour   TimeRange = "LASTHOUR"
	TimeRangeLastday    TimeRange = "LASTDAY"
	TimeRangeLast3days  TimeRange = "LAST3DAYS"
	TimeRangeLast7days  TimeRange = "LAST7DAYS"
	TimeRangeLast30days TimeRange = "LAST30DAYS"
)

// Vector is a custom scalar that is a one to one representation of the equivalent Prometheus API
// type you can see here https://pkg.go.dev/github.com/prometheus/common/model?tab=doc#Vector .
// This type is returned by numerous Prometheus graphQL queries.
type Vector prometheus.Vector

// GetClusterCtx will get cluster by ID
func (c *Client) GetClusterCtx(ctx context.Context, clusterID string) (*Cluster, error) {
	req := graphql.NewRequest(`query($clusterID: ID!) {
		getCluster(clusterID: $clusterID) {` + allClusterFields + `
		}
	}`)
	req.Var("clusterID", clusterID)

	var res struct {
		GetCluster *Cluster `json:"getCluster"`
	}
	if err := c.makeRequest(ctx, req, &res); err != nil {
		return nil, err
	}

	return res.GetCluster, nil
}

// GetCluster will get cluster by ID
func (c *Client) GetCluster(clusterID string) (*Cluster, error) {
	return c.GetClusterCtx(context.Background(), clusterID)
}

// GetAllClustersCtx will get all clusters provisioned on the tenant
func (c *Client) GetAllClustersCtx(ctx context.Context, role string) ([]Cluster, error) {
	req := graphql.NewRequest(`query($role: String!) {
		getAllClusters(role: $role) {` + allClusterFields + `
		}
	}`)
	req.Var("role", role)

	var res struct {
		GetAllClusters []Cluster `json:"getAllClusters"`
	}
	if err := c.makeRequest(ctx, req, &res); err != nil {
		return nil, err
	}

	return res.GetAllClusters, nil
}

// GetAllClusters will get all clusters provisioned on the tenant
func (c *Client) GetAllClusters(role string) ([]Cluster, error) {
	return c.GetAllClustersCtx(context.Background(), role)
}

// GetClusterConfigCtx will get a cluster's config
func (c *Client) GetClusterConfigCtx(ctx context.Context, clusterID string) (*KubernetesConfig, error) {
	req := graphql.NewRequest(`query($clusterID: ID!) {
		getClusterConfig(clusterID: $clusterID)
	}`)
	req.Var("clusterID", clusterID)

	var res struct {
		GetClusterConfig *KubernetesConfig `json:"getClusterConfig"`
	}
	if err := c.makeRequest(ctx, req, &res); err != nil {
		return nil, err
	}

	return res.GetClusterConfig, nil
}

// GetClusterConfig will get a cluster's config
func (c *Client) GetClusterConfig(clusterID string) (*KubernetesConfig, error) {
	return c.GetClusterConfigCtx(context.Background(), clusterID)
}

// GetClusterImageArguments is the parameters for GetClusterImage
type GetClusterImageArguments struct {
	ClusterID     string      `json:"clusterID"`
	ImageType     ImageType   `json:"imageType"`
	LaunchConsole *bool       `json:"launchConsole"`
	AwsDetails    *AWSDetails `json:"awsDetails"`
}

// GetClusterImageCtx will get a cluster's image download link
func (c *Client) GetClusterImageCtx(ctx context.Context, params *GetClusterImageArguments) (*Image, error) {
	req := graphql.NewRequest(`query($clusterID: ID!, $imageType: ImageType!, $launchConsole: Boolean, $awsDetails: AWSDetails) {
		getClusterImage(clusterID: $clusterID, imageType: $imageType, launchConsole: $launchConsole, awsDetails: $awsDetails) {` + allImageFields + `
		}
	}`)
	req.Var("clusterID", params.ClusterID)
	req.Var("imageType", params.ImageType)
	req.Var("launchConsole", params.LaunchConsole)
	req.Var("awsDetails", params.AwsDetails)

	var res struct {
		GetClusterImage *Image `json:"getClusterImage"`
	}
	if err := c.makeRequest(ctx, req, &res); err != nil {
		return nil, err
	}

	return res.GetClusterImage, nil
}

// GetClusterImage will get a cluster's image download link
func (c *Client) GetClusterImage(params *GetClusterImageArguments) (*Image, error) {
	return c.GetClusterImageCtx(context.Background(), params)
}

// GetClusterCredentialsCtx will get a cluster's credentials
func (c *Client) GetClusterCredentialsCtx(ctx context.Context, clusterID string) (*Credentials, error) {
	req := graphql.NewRequest(`query($clusterID: ID!) {
		getClusterCredentials(clusterID: $clusterID) {` + allCredentialsFields + `
		}
	}`)
	req.Var("clusterID", clusterID)

	var res struct {
		GetClusterCredentials *Credentials `json:"getClusterCredentials"`
	}
	if err := c.makeRequest(ctx, req, &res); err != nil {
		return nil, err
	}

	return res.GetClusterCredentials, nil
}

// GetClusterCredentials will get a cluster's credentials
func (c *Client) GetClusterCredentials(clusterID string) (*Credentials, error) {
	return c.GetClusterCredentialsCtx(context.Background(), clusterID)
}

// GetHostsCtx will get all of the host->address mappings associated with a given cluster
func (c *Client) GetHostsCtx(ctx context.Context, clusterID string) (*Hosts, error) {
	req := graphql.NewRequest(`query($clusterID: ID!) {
		getHosts(clusterID: $clusterID)
	}`)
	req.Var("clusterID", clusterID)

	var res struct {
		GetHosts *Hosts `json:"getHosts"`
	}
	if err := c.makeRequest(ctx, req, &res); err != nil {
		return nil, err
	}

	return res.GetHosts, nil
}

// GetHosts will get all of the host->address mappings associated with a given cluster
func (c *Client) GetHosts(clusterID string) (*Hosts, error) {
	return c.GetHostsCtx(context.Background(), clusterID)
}

func (c *Client) GetOSConfigCtx(ctx context.Context, clusterID string) (*OSConfig, error) {
	req := graphql.NewRequest(`query($clusterID: ID!) {
		getOSConfig(clusterID: $clusterID) {` + allOSConfigFields + `
		}
	}`)
	req.Var("clusterID", clusterID)

	var res struct {
		GetOSConfig *OSConfig `json:"getOSConfig"`
	}
	if err := c.makeRequest(ctx, req, &res); err != nil {
		return nil, err
	}

	return res.GetOSConfig, nil
}

func (c *Client) GetOSConfig(clusterID string) (*OSConfig, error) {
	return c.GetOSConfigCtx(context.Background(), clusterID)
}

// GetClusterStatusesCtx will get a cluster's statuses and helm resources deployed
func (c *Client) GetClusterStatusesCtx(ctx context.Context, clusterID string) ([]Status, error) {
	req := graphql.NewRequest(`query($clusterID: ID!) {
		getClusterStatuses(clusterID: $clusterID) {` + allStatusFields + `
		}
	}`)
	req.Var("clusterID", clusterID)

	var res struct {
		GetClusterStatuses []Status `json:"getClusterStatuses"`
	}
	if err := c.makeRequest(ctx, req, &res); err != nil {
		return nil, err
	}

	return res.GetClusterStatuses, nil
}

// GetClusterStatuses will get a cluster's statuses and helm resources deployed
func (c *Client) GetClusterStatuses(clusterID string) ([]Status, error) {
	return c.GetClusterStatusesCtx(context.Background(), clusterID)
}

// GetClusterDeploymentStatusCtx will get the status of a cluster deployment
func (c *Client) GetClusterDeploymentStatusCtx(ctx context.Context, clusterID string, deploymentID string) (*Map, error) {
	req := graphql.NewRequest(`query($clusterID: ID!, $deploymentID: ID!) {
		getClusterDeploymentStatus(clusterID: $clusterID, deploymentID: $deploymentID)
	}`)
	req.Var("clusterID", clusterID)
	req.Var("deploymentID", deploymentID)

	var res struct {
		GetClusterDeploymentStatus *Map `json:"getClusterDeploymentStatus"`
	}
	if err := c.makeRequest(ctx, req, &res); err != nil {
		return nil, err
	}

	return res.GetClusterDeploymentStatus, nil
}

// GetClusterDeploymentStatus will get the status of a cluster deployment
func (c *Client) GetClusterDeploymentStatus(clusterID string, deploymentID string) (*Map, error) {
	return c.GetClusterDeploymentStatusCtx(context.Background(), clusterID, deploymentID)
}

// GetChartCtx will get a single Helm chart by name
func (c *Client) GetChartCtx(ctx context.Context, chartName string) (*Chart, error) {
	req := graphql.NewRequest(`query($chartName: String!) {
		getChart(chartName: $chartName) {` + allChartFields + `
		}
	}`)
	req.Var("chartName", chartName)

	var res struct {
		GetChart *Chart `json:"getChart"`
	}
	if err := c.makeRequest(ctx, req, &res); err != nil {
		return nil, err
	}

	return res.GetChart, nil
}

// GetChart will get a single Helm chart by name
func (c *Client) GetChart(chartName string) (*Chart, error) {
	return c.GetChartCtx(context.Background(), chartName)
}

// GetAllChartsCtx will get all of the Helm charts available for deployment to any cluster
func (c *Client) GetAllChartsCtx(ctx context.Context) (*ChartList, error) {
	req := graphql.NewRequest(`query {
		getAllCharts {` + allChartListFields + `
		}
	}`)

	var res struct {
		GetAllCharts *ChartList `json:"getAllCharts"`
	}
	if err := c.makeRequest(ctx, req, &res); err != nil {
		return nil, err
	}

	return res.GetAllCharts, nil
}

// GetAllCharts will get all of the Helm charts available for deployment to any cluster
func (c *Client) GetAllCharts() (*ChartList, error) {
	return c.GetAllChartsCtx(context.Background())
}

// GetClusterDeploymentCtx will get a single deployment under a collector
func (c *Client) GetClusterDeploymentCtx(ctx context.Context, clusterID string, deploymentID string) (*Deployment, error) {
	req := graphql.NewRequest(`query($clusterID: ID!, $deploymentID: ID!) {
		getClusterDeployment(clusterID: $clusterID, deploymentID: $deploymentID) {` + allDeploymentFields + `
		}
	}`)
	req.Var("clusterID", clusterID)
	req.Var("deploymentID", deploymentID)

	var res struct {
		GetClusterDeployment *Deployment `json:"getClusterDeployment"`
	}
	if err := c.makeRequest(ctx, req, &res); err != nil {
		return nil, err
	}

	return res.GetClusterDeployment, nil
}

// GetClusterDeployment will get a single deployment under a collector
func (c *Client) GetClusterDeployment(clusterID string, deploymentID string) (*Deployment, error) {
	return c.GetClusterDeploymentCtx(context.Background(), clusterID, deploymentID)
}

// GetAllClusterDeploymentsCtx will get all of the deployments under a collector
func (c *Client) GetAllClusterDeploymentsCtx(ctx context.Context, clusterID string) ([]Deployment, error) {
	req := graphql.NewRequest(`query($clusterID: ID!) {
		getAllClusterDeployments(clusterID: $clusterID) {` + allDeploymentFields + `
		}
	}`)
	req.Var("clusterID", clusterID)

	var res struct {
		GetAllClusterDeployments []Deployment `json:"getAllClusterDeployments"`
	}
	if err := c.makeRequest(ctx, req, &res); err != nil {
		return nil, err
	}

	return res.GetAllClusterDeployments, nil
}

// GetAllClusterDeployments will get all of the deployments under a collector
func (c *Client) GetAllClusterDeployments(clusterID string) ([]Deployment, error) {
	return c.GetAllClusterDeploymentsCtx(context.Background(), clusterID)
}

// GetDeploymentEndpointCtx will get an endpoint configured for a given deployment
func (c *Client) GetDeploymentEndpointCtx(ctx context.Context, clusterID string, deploymentID string, endpointID string) (*Endpoint, error) {
	req := graphql.NewRequest(`query($clusterID: ID!, $deploymentID: ID!, $endpointID: ID!) {
		getDeploymentEndpoint(clusterID: $clusterID, deploymentID: $deploymentID, endpointID: $endpointID) {` + allEndpointFields + `
		}
	}`)
	req.Var("clusterID", clusterID)
	req.Var("deploymentID", deploymentID)
	req.Var("endpointID", endpointID)

	var res struct {
		GetDeploymentEndpoint *Endpoint `json:"getDeploymentEndpoint"`
	}
	if err := c.makeRequest(ctx, req, &res); err != nil {
		return nil, err
	}

	return res.GetDeploymentEndpoint, nil
}

// GetDeploymentEndpoint will get an endpoint configured for a given deployment
func (c *Client) GetDeploymentEndpoint(clusterID string, deploymentID string, endpointID string) (*Endpoint, error) {
	return c.GetDeploymentEndpointCtx(context.Background(), clusterID, deploymentID, endpointID)
}

// GetAllDeploymentEndpointsCtx will get all of the endpoints configured for a given deployment
func (c *Client) GetAllDeploymentEndpointsCtx(ctx context.Context, clusterID string, deploymentID string) ([]Endpoint, error) {
	req := graphql.NewRequest(`query($clusterID: ID!, $deploymentID: ID!) {
		getAllDeploymentEndpoints(clusterID: $clusterID, deploymentID: $deploymentID) {` + allEndpointFields + `
		}
	}`)
	req.Var("clusterID", clusterID)
	req.Var("deploymentID", deploymentID)

	var res struct {
		GetAllDeploymentEndpoints []Endpoint `json:"getAllDeploymentEndpoints"`
	}
	if err := c.makeRequest(ctx, req, &res); err != nil {
		return nil, err
	}

	return res.GetAllDeploymentEndpoints, nil
}

// GetAllDeploymentEndpoints will get all of the endpoints configured for a given deployment
func (c *Client) GetAllDeploymentEndpoints(clusterID string, deploymentID string) ([]Endpoint, error) {
	return c.GetAllDeploymentEndpointsCtx(context.Background(), clusterID, deploymentID)
}

// GetAWSRegionsCtx will fetch list of AWS regions where we have images available
func (c *Client) GetAWSRegionsCtx(ctx context.Context) ([]string, error) {
	req := graphql.NewRequest(`query {
		getAWSRegions
	}`)

	var res struct {
		GetAWSRegions []string `json:"getAWSRegions"`
	}
	if err := c.makeRequest(ctx, req, &res); err != nil {
		return nil, err
	}

	return res.GetAWSRegions, nil
}

// GetAWSRegions will fetch list of AWS regions where we have images available
func (c *Client) GetAWSRegions() ([]string, error) {
	return c.GetAWSRegionsCtx(context.Background())
}

// GetRoleDeploymentsCtx will get deployments to be installed on every cluster of a given role.
func (c *Client) GetRoleDeploymentsCtx(ctx context.Context, role string) ([]Deployment, error) {
	req := graphql.NewRequest(`query($role: String!) {
		getRoleDeployments(role: $role) {` + allDeploymentFields + `
		}
	}`)
	req.Var("role", role)

	var res struct {
		GetRoleDeployments []Deployment `json:"getRoleDeployments"`
	}
	if err := c.makeRequest(ctx, req, &res); err != nil {
		return nil, err
	}

	return res.GetRoleDeployments, nil
}

// GetRoleDeployments will get deployments to be installed on every cluster of a given role.
func (c *Client) GetRoleDeployments(role string) ([]Deployment, error) {
	return c.GetRoleDeploymentsCtx(context.Background(), role)
}

// GetRoleDeploymentCtx will get a role based deployment by ID.
func (c *Client) GetRoleDeploymentCtx(ctx context.Context, deploymentID string) (*Deployment, error) {
	req := graphql.NewRequest(`query($deploymentID: ID!) {
		getRoleDeployment(deploymentID: $deploymentID) {` + allDeploymentFields + `
		}
	}`)
	req.Var("deploymentID", deploymentID)

	var res struct {
		GetRoleDeployment *Deployment `json:"getRoleDeployment"`
	}
	if err := c.makeRequest(ctx, req, &res); err != nil {
		return nil, err
	}

	return res.GetRoleDeployment, nil
}

// GetRoleDeployment will get a role based deployment by ID.
func (c *Client) GetRoleDeployment(deploymentID string) (*Deployment, error) {
	return c.GetRoleDeploymentCtx(context.Background(), deploymentID)
}

// GetAllCollectorsOverviewCtx will get all collector overview data for the given role and time range
func (c *Client) GetAllCollectorsOverviewCtx(ctx context.Context, role string, timeRange TimeRange) ([]CollectorOverview, error) {
	req := graphql.NewRequest(`query($role: String!, $timeRange: TimeRange!) {
		getAllCollectorsOverview(role: $role, timeRange: $timeRange) {` + allCollectorOverviewFields + `
		}
	}`)
	req.Var("role", role)
	req.Var("timeRange", timeRange)

	var res struct {
		GetAllCollectorsOverview []CollectorOverview `json:"getAllCollectorsOverview"`
	}
	if err := c.makeRequest(ctx, req, &res); err != nil {
		return nil, err
	}

	return res.GetAllCollectorsOverview, nil
}

// GetAllCollectorsOverview will get all collector overview data for the given role and time range
func (c *Client) GetAllCollectorsOverview(role string, timeRange TimeRange) ([]CollectorOverview, error) {
	return c.GetAllCollectorsOverviewCtx(context.Background(), role, timeRange)
}

// GetCollectorMetricsCtx will get collector data flow metrics over a given time range
func (c *Client) GetCollectorMetricsCtx(ctx context.Context, timeRange TimeRange) (*CollectorMetrics, error) {
	req := graphql.NewRequest(`query($timeRange: TimeRange!) {
		getCollectorMetrics(timeRange: $timeRange) {` + allCollectorMetricsFields + `
		}
	}`)
	req.Var("timeRange", timeRange)

	var res struct {
		GetCollectorMetrics *CollectorMetrics `json:"getCollectorMetrics"`
	}
	if err := c.makeRequest(ctx, req, &res); err != nil {
		return nil, err
	}

	return res.GetCollectorMetrics, nil
}

// GetCollectorMetrics will get collector data flow metrics over a given time range
func (c *Client) GetCollectorMetrics(timeRange TimeRange) (*CollectorMetrics, error) {
	return c.GetCollectorMetricsCtx(context.Background(), timeRange)
}

// GetAggregateRateByCollectorCtx will get aggregated data flow rate metrics for a given collector over a given time range
func (c *Client) GetAggregateRateByCollectorCtx(ctx context.Context, clusterID string, timeRange TimeRange) (*AggregateRateByCollector, error) {
	req := graphql.NewRequest(`query($clusterID: ID!, $timeRange: TimeRange!) {
		getAggregateRateByCollector(clusterID: $clusterID, timeRange: $timeRange) {` + allAggregateRateByCollectorFields + `
		}
	}`)
	req.Var("clusterID", clusterID)
	req.Var("timeRange", timeRange)

	var res struct {
		GetAggregateRateByCollector *AggregateRateByCollector `json:"getAggregateRateByCollector"`
	}
	if err := c.makeRequest(ctx, req, &res); err != nil {
		return nil, err
	}

	return res.GetAggregateRateByCollector, nil
}

// GetAggregateRateByCollector will get aggregated data flow rate metrics for a given collector over a given time range
func (c *Client) GetAggregateRateByCollector(clusterID string, timeRange TimeRange) (*AggregateRateByCollector, error) {
	return c.GetAggregateRateByCollectorCtx(context.Background(), clusterID, timeRange)
}

// GetFlowRateCtx will get flow rate metrics for a given collector over a given time range
func (c *Client) GetFlowRateCtx(ctx context.Context, clusterID string, timeRange TimeRange) (*FlowRate, error) {
	req := graphql.NewRequest(`query($clusterID: ID!, $timeRange: TimeRange!) {
		getFlowRate(clusterID: $clusterID, timeRange: $timeRange) {` + allFlowRateFields + `
		}
	}`)
	req.Var("clusterID", clusterID)
	req.Var("timeRange", timeRange)

	var res struct {
		GetFlowRate *FlowRate `json:"getFlowRate"`
	}
	if err := c.makeRequest(ctx, req, &res); err != nil {
		return nil, err
	}

	return res.GetFlowRate, nil
}

// GetFlowRate will get flow rate metrics for a given collector over a given time range
func (c *Client) GetFlowRate(clusterID string, timeRange TimeRange) (*FlowRate, error) {
	return c.GetFlowRateCtx(context.Background(), clusterID, timeRange)
}

// GetLogLastSeenMetricsCtx will get last seen metrics for all available log sources for a given cluster.
//     If no clusterId is specified, this will return all log sources metrics for all existing clusters
func (c *Client) GetLogLastSeenMetricsCtx(ctx context.Context, clusterID *string) (*LogLastSeenMetrics, error) {
	req := graphql.NewRequest(`query($clusterID: ID) {
		getLogLastSeenMetrics(clusterID: $clusterID) {` + allLogLastSeenMetricsFields + `
		}
	}`)
	req.Var("clusterID", clusterID)

	var res struct {
		GetLogLastSeenMetrics *LogLastSeenMetrics `json:"getLogLastSeenMetrics"`
	}
	if err := c.makeRequest(ctx, req, &res); err != nil {
		return nil, err
	}

	return res.GetLogLastSeenMetrics, nil
}

// GetLogLastSeenMetrics will get last seen metrics for all available log sources for a given cluster.
//     If no clusterId is specified, this will return all log sources metrics for all existing clusters
func (c *Client) GetLogLastSeenMetrics(clusterID *string) (*LogLastSeenMetrics, error) {
	return c.GetLogLastSeenMetricsCtx(context.Background(), clusterID)
}

// CreateClusterCtx will create a new cluster of a given role
func (c *Client) CreateClusterCtx(ctx context.Context, clusterInput ClusterInput) (*Cluster, error) {
	req := graphql.NewRequest(`mutation($clusterInput: ClusterInput!) {
		createCluster(clusterInput: $clusterInput) {` + allClusterFields + `
		}
	}`)
	req.Var("clusterInput", clusterInput)

	var res struct {
		CreateCluster *Cluster `json:"createCluster"`
	}
	if err := c.makeRequest(ctx, req, &res); err != nil {
		return nil, err
	}

	return res.CreateCluster, nil
}

// CreateCluster will create a new cluster of a given role
func (c *Client) CreateCluster(clusterInput ClusterInput) (*Cluster, error) {
	return c.CreateClusterCtx(context.Background(), clusterInput)
}

// UpdateClusterCtx will update a cluster
func (c *Client) UpdateClusterCtx(ctx context.Context, clusterID string, clusterInput ClusterInput) (*Cluster, error) {
	req := graphql.NewRequest(`mutation($clusterID: ID!, $clusterInput: ClusterInput!) {
		updateCluster(clusterID: $clusterID, clusterInput: $clusterInput) {` + allClusterFields + `
		}
	}`)
	req.Var("clusterID", clusterID)
	req.Var("clusterInput", clusterInput)

	var res struct {
		UpdateCluster *Cluster `json:"updateCluster"`
	}
	if err := c.makeRequest(ctx, req, &res); err != nil {
		return nil, err
	}

	return res.UpdateCluster, nil
}

// UpdateCluster will update a cluster
func (c *Client) UpdateCluster(clusterID string, clusterInput ClusterInput) (*Cluster, error) {
	return c.UpdateClusterCtx(context.Background(), clusterID, clusterInput)
}

// DeleteClusterCtx will delete a cluster
func (c *Client) DeleteClusterCtx(ctx context.Context, clusterID string) (*Deleted, error) {
	req := graphql.NewRequest(`mutation($clusterID: ID!) {
		deleteCluster(clusterID: $clusterID) {` + allDeletedFields + `
		}
	}`)
	req.Var("clusterID", clusterID)

	var res struct {
		DeleteCluster *Deleted `json:"deleteCluster"`
	}
	if err := c.makeRequest(ctx, req, &res); err != nil {
		return nil, err
	}

	return res.DeleteCluster, nil
}

// DeleteCluster will delete a cluster
func (c *Client) DeleteCluster(clusterID string) (*Deleted, error) {
	return c.DeleteClusterCtx(context.Background(), clusterID)
}

func (c *Client) CreateOSConfigCtx(ctx context.Context, input OSConfigInput) (*OSConfig, error) {
	req := graphql.NewRequest(`mutation($input: OSConfigInput!) {
		createOSConfig(input: $input) {` + allOSConfigFields + `
		}
	}`)
	req.Var("input", input)

	var res struct {
		CreateOSConfig *OSConfig `json:"createOSConfig"`
	}
	if err := c.makeRequest(ctx, req, &res); err != nil {
		return nil, err
	}

	return res.CreateOSConfig, nil
}

func (c *Client) CreateOSConfig(input OSConfigInput) (*OSConfig, error) {
	return c.CreateOSConfigCtx(context.Background(), input)
}

func (c *Client) UpdateOSConfigCtx(ctx context.Context, input OSConfigInput) (*OSConfig, error) {
	req := graphql.NewRequest(`mutation($input: OSConfigInput!) {
		updateOSConfig(input: $input) {` + allOSConfigFields + `
		}
	}`)
	req.Var("input", input)

	var res struct {
		UpdateOSConfig *OSConfig `json:"updateOSConfig"`
	}
	if err := c.makeRequest(ctx, req, &res); err != nil {
		return nil, err
	}

	return res.UpdateOSConfig, nil
}

func (c *Client) UpdateOSConfig(input OSConfigInput) (*OSConfig, error) {
	return c.UpdateOSConfigCtx(context.Background(), input)
}

func (c *Client) DeleteOSConfigCtx(ctx context.Context, clusterID string) (string, error) {
	req := graphql.NewRequest(`mutation($clusterID: ID!) {
		deleteOSConfig(clusterID: $clusterID)
	}`)
	req.Var("clusterID", clusterID)

	var res struct {
		DeleteOSConfig string `json:"deleteOSConfig"`
	}
	if err := c.makeRequest(ctx, req, &res); err != nil {
		return "", err
	}

	return res.DeleteOSConfig, nil
}

func (c *Client) DeleteOSConfig(clusterID string) (string, error) {
	return c.DeleteOSConfigCtx(context.Background(), clusterID)
}

// AddHostCtx will add a address:hostname mapping to a given cluster
func (c *Client) AddHostCtx(ctx context.Context, clusterID string, hostInput HostsInput) (*Hosts, error) {
	req := graphql.NewRequest(`mutation($clusterID: ID!, $hostInput: HostsInput!) {
		addHost(clusterID: $clusterID, hostInput: $hostInput)
	}`)
	req.Var("clusterID", clusterID)
	req.Var("hostInput", hostInput)

	var res struct {
		AddHost *Hosts `json:"addHost"`
	}
	if err := c.makeRequest(ctx, req, &res); err != nil {
		return nil, err
	}

	return res.AddHost, nil
}

// AddHost will add a address:hostname mapping to a given cluster
func (c *Client) AddHost(clusterID string, hostInput HostsInput) (*Hosts, error) {
	return c.AddHostCtx(context.Background(), clusterID, hostInput)
}

// DeleteHostCtx will remove an address:hostname mapping from a given cluster by providing the IP address and associated host name
func (c *Client) DeleteHostCtx(ctx context.Context, clusterID string, address string) (*Deleted, error) {
	req := graphql.NewRequest(`mutation($clusterID: ID!, $address: String!) {
		deleteHost(clusterID: $clusterID, address: $address) {` + allDeletedFields + `
		}
	}`)
	req.Var("clusterID", clusterID)
	req.Var("address", address)

	var res struct {
		DeleteHost *Deleted `json:"deleteHost"`
	}
	if err := c.makeRequest(ctx, req, &res); err != nil {
		return nil, err
	}

	return res.DeleteHost, nil
}

// DeleteHost will remove an address:hostname mapping from a given cluster by providing the IP address and associated host name
func (c *Client) DeleteHost(clusterID string, address string) (*Deleted, error) {
	return c.DeleteHostCtx(context.Background(), clusterID, address)
}

// CreateClusterStatusCtx will create the initial deployment status of a given cluster
func (c *Client) CreateClusterStatusCtx(ctx context.Context, clusterID string, statusInput StatusInput) (*Status, error) {
	req := graphql.NewRequest(`mutation($clusterID: ID!, $statusInput: StatusInput!) {
		createClusterStatus(clusterID: $clusterID, statusInput: $statusInput) {` + allStatusFields + `
		}
	}`)
	req.Var("clusterID", clusterID)
	req.Var("statusInput", statusInput)

	var res struct {
		CreateClusterStatus *Status `json:"createClusterStatus"`
	}
	if err := c.makeRequest(ctx, req, &res); err != nil {
		return nil, err
	}

	return res.CreateClusterStatus, nil
}

// CreateClusterStatus will create the initial deployment status of a given cluster
func (c *Client) CreateClusterStatus(clusterID string, statusInput StatusInput) (*Status, error) {
	return c.CreateClusterStatusCtx(context.Background(), clusterID, statusInput)
}

// UpdateClusterStatusCtx will update the deployment status of a given cluster
func (c *Client) UpdateClusterStatusCtx(ctx context.Context, clusterID string, statusInput StatusInput) (*Status, error) {
	req := graphql.NewRequest(`mutation($clusterID: ID!, $statusInput: StatusInput!) {
		updateClusterStatus(clusterID: $clusterID, statusInput: $statusInput) {` + allStatusFields + `
		}
	}`)
	req.Var("clusterID", clusterID)
	req.Var("statusInput", statusInput)

	var res struct {
		UpdateClusterStatus *Status `json:"updateClusterStatus"`
	}
	if err := c.makeRequest(ctx, req, &res); err != nil {
		return nil, err
	}

	return res.UpdateClusterStatus, nil
}

// UpdateClusterStatus will update the deployment status of a given cluster
func (c *Client) UpdateClusterStatus(clusterID string, statusInput StatusInput) (*Status, error) {
	return c.UpdateClusterStatusCtx(context.Background(), clusterID, statusInput)
}

// DeleteClusterStatusCtx will delete the deployment status of a given cluster
func (c *Client) DeleteClusterStatusCtx(ctx context.Context, clusterID string, deploymentID string) (*Deleted, error) {
	req := graphql.NewRequest(`mutation($clusterID: ID!, $deploymentID: ID!) {
		deleteClusterStatus(clusterID: $clusterID, deploymentID: $deploymentID) {` + allDeletedFields + `
		}
	}`)
	req.Var("clusterID", clusterID)
	req.Var("deploymentID", deploymentID)

	var res struct {
		DeleteClusterStatus *Deleted `json:"deleteClusterStatus"`
	}
	if err := c.makeRequest(ctx, req, &res); err != nil {
		return nil, err
	}

	return res.DeleteClusterStatus, nil
}

// DeleteClusterStatus will delete the deployment status of a given cluster
func (c *Client) DeleteClusterStatus(clusterID string, deploymentID string) (*Deleted, error) {
	return c.DeleteClusterStatusCtx(context.Background(), clusterID, deploymentID)
}

// CreateClusterDeploymentCtx will create a deployment local to a given cluster
func (c *Client) CreateClusterDeploymentCtx(ctx context.Context, clusterID string, deploymentInput DeploymentInput) (*Deployment, error) {
	req := graphql.NewRequest(`mutation($clusterID: ID!, $deploymentInput: DeploymentInput!) {
		createClusterDeployment(clusterID: $clusterID, deploymentInput: $deploymentInput) {` + allDeploymentFields + `
		}
	}`)
	req.Var("clusterID", clusterID)
	req.Var("deploymentInput", deploymentInput)

	var res struct {
		CreateClusterDeployment *Deployment `json:"createClusterDeployment"`
	}
	if err := c.makeRequest(ctx, req, &res); err != nil {
		return nil, err
	}

	return res.CreateClusterDeployment, nil
}

// CreateClusterDeployment will create a deployment local to a given cluster
func (c *Client) CreateClusterDeployment(clusterID string, deploymentInput DeploymentInput) (*Deployment, error) {
	return c.CreateClusterDeploymentCtx(context.Background(), clusterID, deploymentInput)
}

// UpdateClusterDeploymentCtx will update a deployment on a given cluster
func (c *Client) UpdateClusterDeploymentCtx(ctx context.Context, clusterID string, deploymentID string, deploymentInput DeploymentInput) (*Deployment, error) {
	req := graphql.NewRequest(`mutation($clusterID: ID!, $deploymentID: ID!, $deploymentInput: DeploymentInput!) {
		updateClusterDeployment(clusterID: $clusterID, deploymentID: $deploymentID, deploymentInput: $deploymentInput) {` + allDeploymentFields + `
		}
	}`)
	req.Var("clusterID", clusterID)
	req.Var("deploymentID", deploymentID)
	req.Var("deploymentInput", deploymentInput)

	var res struct {
		UpdateClusterDeployment *Deployment `json:"updateClusterDeployment"`
	}
	if err := c.makeRequest(ctx, req, &res); err != nil {
		return nil, err
	}

	return res.UpdateClusterDeployment, nil
}

// UpdateClusterDeployment will update a deployment on a given cluster
func (c *Client) UpdateClusterDeployment(clusterID string, deploymentID string, deploymentInput DeploymentInput) (*Deployment, error) {
	return c.UpdateClusterDeploymentCtx(context.Background(), clusterID, deploymentID, deploymentInput)
}

// DeleteClusterDeploymentCtx will delete a deployment on a given cluster
func (c *Client) DeleteClusterDeploymentCtx(ctx context.Context, clusterID string, deploymentID string) (*Deleted, error) {
	req := graphql.NewRequest(`mutation($clusterID: ID!, $deploymentID: ID!) {
		deleteClusterDeployment(clusterID: $clusterID, deploymentID: $deploymentID) {` + allDeletedFields + `
		}
	}`)
	req.Var("clusterID", clusterID)
	req.Var("deploymentID", deploymentID)

	var res struct {
		DeleteClusterDeployment *Deleted `json:"deleteClusterDeployment"`
	}
	if err := c.makeRequest(ctx, req, &res); err != nil {
		return nil, err
	}

	return res.DeleteClusterDeployment, nil
}

// DeleteClusterDeployment will delete a deployment on a given cluster
func (c *Client) DeleteClusterDeployment(clusterID string, deploymentID string) (*Deleted, error) {
	return c.DeleteClusterDeploymentCtx(context.Background(), clusterID, deploymentID)
}

// CreateEndpointCtx will create an endpoint for a given cluster
func (c *Client) CreateEndpointCtx(ctx context.Context, clusterID string, deploymentID string, endpointInput EndpointInput) (*Endpoint, error) {
	req := graphql.NewRequest(`mutation($clusterID: ID!, $deploymentID: ID!, $endpointInput: EndpointInput!) {
		createEndpoint(clusterID: $clusterID, deploymentID: $deploymentID, endpointInput: $endpointInput) {` + allEndpointFields + `
		}
	}`)
	req.Var("clusterID", clusterID)
	req.Var("deploymentID", deploymentID)
	req.Var("endpointInput", endpointInput)

	var res struct {
		CreateEndpoint *Endpoint `json:"createEndpoint"`
	}
	if err := c.makeRequest(ctx, req, &res); err != nil {
		return nil, err
	}

	return res.CreateEndpoint, nil
}

// CreateEndpoint will create an endpoint for a given cluster
func (c *Client) CreateEndpoint(clusterID string, deploymentID string, endpointInput EndpointInput) (*Endpoint, error) {
	return c.CreateEndpointCtx(context.Background(), clusterID, deploymentID, endpointInput)
}

// UpdateEndpointArguments is the parameters for UpdateEndpoint
type UpdateEndpointArguments struct {
	ClusterID     string        `json:"clusterID"`
	DeploymentID  string        `json:"deploymentID"`
	EndpointID    string        `json:"endpointID"`
	EndpointInput EndpointInput `json:"endpointInput"`
}

// UpdateEndpointCtx will update an endpoint for a given cluster
func (c *Client) UpdateEndpointCtx(ctx context.Context, params *UpdateEndpointArguments) (*Endpoint, error) {
	req := graphql.NewRequest(`mutation($clusterID: ID!, $deploymentID: ID!, $endpointID: ID!, $endpointInput: EndpointInput!) {
		updateEndpoint(clusterID: $clusterID, deploymentID: $deploymentID, endpointID: $endpointID, endpointInput: $endpointInput) {` + allEndpointFields + `
		}
	}`)
	req.Var("clusterID", params.ClusterID)
	req.Var("deploymentID", params.DeploymentID)
	req.Var("endpointID", params.EndpointID)
	req.Var("endpointInput", params.EndpointInput)

	var res struct {
		UpdateEndpoint *Endpoint `json:"updateEndpoint"`
	}
	if err := c.makeRequest(ctx, req, &res); err != nil {
		return nil, err
	}

	return res.UpdateEndpoint, nil
}

// UpdateEndpoint will update an endpoint for a given cluster
func (c *Client) UpdateEndpoint(params *UpdateEndpointArguments) (*Endpoint, error) {
	return c.UpdateEndpointCtx(context.Background(), params)
}

// DeleteEndpointCtx will delete an endpoint for a given cluster
func (c *Client) DeleteEndpointCtx(ctx context.Context, clusterID string, deploymentID string, endpointID string) (*Deleted, error) {
	req := graphql.NewRequest(`mutation($clusterID: ID!, $deploymentID: ID!, $endpointID: ID!) {
		deleteEndpoint(clusterID: $clusterID, deploymentID: $deploymentID, endpointID: $endpointID) {` + allDeletedFields + `
		}
	}`)
	req.Var("clusterID", clusterID)
	req.Var("deploymentID", deploymentID)
	req.Var("endpointID", endpointID)

	var res struct {
		DeleteEndpoint *Deleted `json:"deleteEndpoint"`
	}
	if err := c.makeRequest(ctx, req, &res); err != nil {
		return nil, err
	}

	return res.DeleteEndpoint, nil
}

// DeleteEndpoint will delete an endpoint for a given cluster
func (c *Client) DeleteEndpoint(clusterID string, deploymentID string, endpointID string) (*Deleted, error) {
	return c.DeleteEndpointCtx(context.Background(), clusterID, deploymentID, endpointID)
}

// CreateRoleDeploymentCtx will create a deployment to be installed on every cluster of a given role. Only Secureworks admins can reach this endpoint.
func (c *Client) CreateRoleDeploymentCtx(ctx context.Context, role string, deploymentInput DeploymentInput) (*Deployment, error) {
	req := graphql.NewRequest(`mutation($role: String!, $deploymentInput: DeploymentInput!) {
		createRoleDeployment(role: $role, deploymentInput: $deploymentInput) {` + allDeploymentFields + `
		}
	}`)
	req.Var("role", role)
	req.Var("deploymentInput", deploymentInput)

	var res struct {
		CreateRoleDeployment *Deployment `json:"createRoleDeployment"`
	}
	if err := c.makeRequest(ctx, req, &res); err != nil {
		return nil, err
	}

	return res.CreateRoleDeployment, nil
}

// CreateRoleDeployment will create a deployment to be installed on every cluster of a given role. Only Secureworks admins can reach this endpoint.
func (c *Client) CreateRoleDeployment(role string, deploymentInput DeploymentInput) (*Deployment, error) {
	return c.CreateRoleDeploymentCtx(context.Background(), role, deploymentInput)
}

// UpdateRoleDeploymentCtx will update a system deployment by ID. Only Secureworks admins can reach this endpoint.
func (c *Client) UpdateRoleDeploymentCtx(ctx context.Context, deploymentID string, deploymentInput DeploymentInput) (*Deployment, error) {
	req := graphql.NewRequest(`mutation($deploymentID: ID!, $deploymentInput: DeploymentInput!) {
		updateRoleDeployment(deploymentID: $deploymentID, deploymentInput: $deploymentInput) {` + allDeploymentFields + `
		}
	}`)
	req.Var("deploymentID", deploymentID)
	req.Var("deploymentInput", deploymentInput)

	var res struct {
		UpdateRoleDeployment *Deployment `json:"updateRoleDeployment"`
	}
	if err := c.makeRequest(ctx, req, &res); err != nil {
		return nil, err
	}

	return res.UpdateRoleDeployment, nil
}

// UpdateRoleDeployment will update a system deployment by ID. Only Secureworks admins can reach this endpoint.
func (c *Client) UpdateRoleDeployment(deploymentID string, deploymentInput DeploymentInput) (*Deployment, error) {
	return c.UpdateRoleDeploymentCtx(context.Background(), deploymentID, deploymentInput)
}

// DeleteRoleDeploymentCtx will delete a system deployment by ID. Only Secureworks admins can reach this endpoint.
func (c *Client) DeleteRoleDeploymentCtx(ctx context.Context, deploymentID string) (*Deleted, error) {
	req := graphql.NewRequest(`mutation($deploymentID: ID!) {
		deleteRoleDeployment(deploymentID: $deploymentID) {` + allDeletedFields + `
		}
	}`)
	req.Var("deploymentID", deploymentID)

	var res struct {
		DeleteRoleDeployment *Deleted `json:"deleteRoleDeployment"`
	}
	if err := c.makeRequest(ctx, req, &res); err != nil {
		return nil, err
	}

	return res.DeleteRoleDeployment, nil
}

// DeleteRoleDeployment will delete a system deployment by ID. Only Secureworks admins can reach this endpoint.
func (c *Client) DeleteRoleDeployment(deploymentID string) (*Deleted, error) {
	return c.DeleteRoleDeploymentCtx(context.Background(), deploymentID)
}
